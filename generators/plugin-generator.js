const fs = require('fs');
const path = require('path');

/**
 * Plugin Generator - Creates complete plugin scaffolding
 * Supports feature plugins and core service plugins
 */
class PluginGenerator {
  constructor(options = {}) {
    this.options = {
      hasStore: false,
      hasRoutes: false,
      hasComponents: false,
      type: 'feature', // 'feature' or 'core'
      ...options
    };
  }

  async generate(options) {
    if (typeof options === 'string') {
      // Legacy call signature: generate(pluginName, targetDir)
      const pluginName = options;
      const targetDir = arguments[1] || process.cwd();
      return this._generatePlugin(pluginName, targetDir);
    }

    // New call signature: generate({ name, type, ... })
    const { name, type = 'feature', hasStore = false, hasRoutes = false, hasComponents = true, description } = options;
    this.options = { ...this.options, type, hasStore, hasRoutes, hasComponents };
    return this._generatePlugin(name, process.cwd());
  }

  async _generatePlugin(pluginName, targetDir = process.cwd()) {
    const pluginDir = path.join(targetDir, 'src', 'plugins', pluginName);

    console.log(`🔌 Generating ${this.options.type} plugin: ${pluginName}`);

    // Create plugin directory structure
    this.createDirectoryStructure(pluginDir);

    // Generate main plugin file
    this.generatePluginClass(pluginName, pluginDir);

    // Generate optional components
    if (this.options.hasStore) {
      this.generatePluginStore(pluginName, pluginDir);
    }

    if (this.options.hasRoutes) {
      this.generatePluginRoutes(pluginName, pluginDir);
    }

    if (this.options.hasComponents) {
      this.generatePluginComponents(pluginName, pluginDir);
    }

    // Generate tests
    this.generatePluginTests(pluginName, pluginDir);

    // Generate index file
    this.generateIndexFile(pluginName, pluginDir);

    console.log(`✅ Plugin ${pluginName} generated successfully!`);
    console.log(`📁 Location: ${pluginDir}`);
    console.log('');
    console.log('Next steps:');
    console.log(`1. Register plugin in src/core/plugins/PluginRegistry.ts`);
    console.log(`2. Import and activate in your app bootstrap`);
    console.log(`3. Implement your plugin functionality`);
  }

  createDirectoryStructure(pluginDir) {
    const dirs = [
      pluginDir,
      path.join(pluginDir, 'components'),
      path.join(pluginDir, 'hooks'),
      path.join(pluginDir, 'types'),
      path.join(pluginDir, '__tests__')
    ];

    if (this.options.hasStore) {
      dirs.push(path.join(pluginDir, 'stores'));
    }

    dirs.forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    });
  }

  generatePluginClass(pluginName, pluginDir) {
    const template = this.getPluginTemplate(pluginName);
    const filePath = path.join(pluginDir, `${pluginName}Plugin.ts`);
    fs.writeFileSync(filePath, template);
  }

  generatePluginStore(pluginName, pluginDir) {
    const template = this.getStoreTemplate(pluginName);
    const filePath = path.join(pluginDir, 'stores', `${pluginName}Store.ts`);
    fs.writeFileSync(filePath, template);
  }

  generatePluginRoutes(pluginName, pluginDir) {
    const template = this.getRoutesTemplate(pluginName);
    const filePath = path.join(pluginDir, `${pluginName}Routes.ts`);
    fs.writeFileSync(filePath, template);
  }

  generatePluginComponents(pluginName, pluginDir) {
    const template = this.getComponentTemplate(pluginName);
    const filePath = path.join(pluginDir, 'components', `${pluginName}Dashboard.tsx`);
    fs.writeFileSync(filePath, template);
  }

  generatePluginTests(pluginName, pluginDir) {
    const template = this.getTestTemplate(pluginName);
    const filePath = path.join(pluginDir, '__tests__', `${pluginName}Plugin.test.ts`);
    fs.writeFileSync(filePath, template);
  }

  generateIndexFile(pluginName, pluginDir) {
    const template = this.getIndexTemplate(pluginName);
    const filePath = path.join(pluginDir, 'index.ts');
    fs.writeFileSync(filePath, template);
  }

  getPluginTemplate(pluginName) {
    return `/**
 * @fileoverview ${pluginName} Plugin
 *
 * ${this.options.type === 'feature' ? 'Feature plugin providing' : 'Core service plugin for'} ${pluginName.toLowerCase()} functionality
 * Generated by AI-First SaaS React Starter CLI
 */

import {
  Plugin,
  PluginContext,
  EventListenerConfig,
  RouteConfig
} from '../../core/plugins/pluginTypes';
import { ${this.getEventImports()} } from '../../core/plugins/coreEvents';${this.options.hasStore ? `
import { use${pluginName}Store } from './stores/${pluginName}Store';` : ''}${this.options.withRoutes ? `
import { ${pluginName.toLowerCase()}Routes } from './${pluginName}Routes';` : ''}

export class ${pluginName}Plugin implements Plugin {
  name = '${pluginName}';
  version = '1.0.0';
  description = '${pluginName} ${this.options.type === 'feature' ? 'feature' : 'service'} plugin';
  author = 'AI-First SaaS';

  private unsubscribers: (() => void)[] = [];

  async install(context: PluginContext): Promise<void> {
    console.log(\`Installing \${this.name} plugin...\`);

    // Plugin installation logic
    // Initialize any required resources
  }

  async activate(context: PluginContext): Promise<void> {
    console.log(\`Activating \${this.name} plugin...\`);

    // Subscribe to relevant core events
    const unsubAuth = context.on(AUTH_EVENTS.USER_LOGIN, this.handleUserLogin);
    const unsubTenant = context.on(TENANT_EVENTS.TENANT_SWITCHED, this.handleTenantSwitch);

    this.unsubscribers.push(unsubAuth, unsubTenant);

    // Emit plugin activated event
    context.emit('plugin.activated', {
      plugin: this.name,
      features: [${this.getFeaturesList()}]
    });
  }

  async deactivate(): Promise<void> {
    console.log(\`Deactivating \${this.name} plugin...\`);

    // Clean up event listeners
    this.unsubscribers.forEach(unsubscribe => unsubscribe());
    this.unsubscribers = [];
  }${this.options.hasStore ? `

  registerStores(context: PluginContext) {
    return {
      ${pluginName.toLowerCase()}: use${pluginName}Store
    };
  }` : ''}${this.options.withRoutes ? `

  registerRoutes(context: PluginContext): RouteConfig[] {
    return ${pluginName.toLowerCase()}Routes(context);
  }` : ''}

  getEventListeners(): EventListenerConfig[] {
    return [
      {
        eventType: AUTH_EVENTS.USER_LOGIN,
        handler: this.handleUserLogin,
        priority: 5
      },
      {
        eventType: TENANT_EVENTS.TENANT_SWITCHED,
        handler: this.handleTenantSwitch,
        priority: 5
      }
    ];
  }

  // Event handlers
  private handleUserLogin = (event: any) => {
    console.log('${pluginName}: User logged in', event.payload);
    // Handle user login logic
  };

  private handleTenantSwitch = (event: any) => {
    console.log('${pluginName}: Tenant switched', event.payload);
    // Handle tenant switch logic
  };
}
`;
  }

  getStoreTemplate(pluginName) {
    return `/**
 * @fileoverview ${pluginName} Store
 *
 * Zustand store for ${pluginName.toLowerCase()} state management
 * Generated by AI-First SaaS React Starter CLI
 */

import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import { apiHelper } from '../../../core/api/apiHelper';
import type { AppError } from '../../../core/stores/base';

interface ${pluginName}Item {
  id: string;
  name: string;
  description?: string;
  createdAt: string;
  updatedAt: string;
}

interface ${pluginName}State {
  // Data
  items: ${pluginName}Item[];
  selectedItem: ${pluginName}Item | null;

  // Request state
  loading: boolean;
  error: AppError | null;

  // Actions
  fetchItems: () => Promise<void>;
  createItem: (data: Partial<${pluginName}Item>) => Promise<void>;
  updateItem: (id: string, data: Partial<${pluginName}Item>) => Promise<void>;
  deleteItem: (id: string) => Promise<void>;
  setSelectedItem: (item: ${pluginName}Item | null) => void;
  clearError: () => void;
}

export const use${pluginName}Store = create<${pluginName}State>()(
  devtools(
    (set, get) => ({
      // Initial state
      items: [],
      selectedItem: null,
      loading: false,
      error: null,

      // Actions
      fetchItems: async () => {
        set({ loading: true, error: null });

        try {
          const response = await apiHelper.get('/${pluginName.toLowerCase()}/items');
          set({
            items: response.data,
            loading: false
          });
        } catch (error: any) {
          set({
            error: {
              message: error.response?.data?.message || 'Failed to fetch items',
              code: error.response?.data?.code
            },
            loading: false
          });
        }
      },

      createItem: async (data: Partial<${pluginName}Item>) => {
        set({ loading: true, error: null });

        try {
          const response = await apiHelper.post('/${pluginName.toLowerCase()}/items', data);
          set(state => ({
            items: [...state.items, response.data],
            loading: false
          }));
        } catch (error: any) {
          set({
            error: {
              message: error.response?.data?.message || 'Failed to create item',
              code: error.response?.data?.code
            },
            loading: false
          });
        }
      },

      updateItem: async (id: string, data: Partial<${pluginName}Item>) => {
        set({ loading: true, error: null });

        try {
          const response = await apiHelper.put(\`/${pluginName.toLowerCase()}/items/\${id}\`, data);
          set(state => ({
            items: state.items.map(item => item.id === id ? response.data : item),
            selectedItem: state.selectedItem?.id === id ? response.data : state.selectedItem,
            loading: false
          }));
        } catch (error: any) {
          set({
            error: {
              message: error.response?.data?.message || 'Failed to update item',
              code: error.response?.data?.code
            },
            loading: false
          });
        }
      },

      deleteItem: async (id: string) => {
        set({ loading: true, error: null });

        try {
          await apiHelper.delete(\`/${pluginName.toLowerCase()}/items/\${id}\`);
          set(state => ({
            items: state.items.filter(item => item.id !== id),
            selectedItem: state.selectedItem?.id === id ? null : state.selectedItem,
            loading: false
          }));
        } catch (error: any) {
          set({
            error: {
              message: error.response?.data?.message || 'Failed to delete item',
              code: error.response?.data?.code
            },
            loading: false
          });
        }
      },

      setSelectedItem: (item: ${pluginName}Item | null) => {
        set({ selectedItem: item });
      },

      clearError: () => {
        set({ error: null });
      }
    }),
    { name: '${pluginName.toLowerCase()}-store' }
  )
);

export default use${pluginName}Store;
`;
  }

  getRoutesTemplate(pluginName) {
    return `/**
 * @fileoverview ${pluginName} Routes
 *
 * Route configuration for ${pluginName} plugin
 * Generated by AI-First SaaS React Starter CLI
 */

import { PluginContext, RouteConfig } from '../../core/plugins/pluginTypes';

export const ${pluginName.toLowerCase()}Routes = (context: PluginContext): RouteConfig[] => [
  {
    path: '/${pluginName.toLowerCase()}',
    component: () => import('./components/${pluginName}Dashboard').then(m => m.default),
    requiresAuth: true,
    requiresTenant: true,
    onEnter: () => context.emit('navigation.${pluginName.toLowerCase()}.entered', {}),
    onExit: () => context.emit('navigation.${pluginName.toLowerCase()}.exited', {})
  },
  {
    path: '/${pluginName.toLowerCase()}/:id',
    component: () => import('./components/${pluginName}Detail').then(m => m.default),
    requiresAuth: true,
    requiresTenant: true,
    onEnter: () => context.emit('navigation.${pluginName.toLowerCase()}.detail.entered', {})
  }
];
`;
  }

  getComponentTemplate(pluginName) {
    return `/**
 * @fileoverview ${pluginName} Dashboard Component
 *
 * Main dashboard component for ${pluginName} plugin
 * Generated by AI-First SaaS React Starter CLI
 */

import React, { useEffect } from 'react';
import {
  Card,
  Typography,
  Button,
  Table,
  Space,
  message,
  Spin
} from 'antd';
import { PlusOutlined, EditOutlined, DeleteOutlined } from '@ant-design/icons';${this.options.hasStore ? `
import { use${pluginName}Store } from '../stores/${pluginName}Store';` : ''}

const { Title } = Typography;

export const ${pluginName}Dashboard: React.FC = () => {${this.options.hasStore ? `
  const {
    items,
    loading,
    error,
    fetchItems,
    deleteItem,
    clearError
  } = use${pluginName}Store();

  useEffect(() => {
    fetchItems();
  }, [fetchItems]);

  useEffect(() => {
    if (error) {
      message.error(error.message);
      clearError();
    }
  }, [error, clearError]);

  const handleDelete = async (id: string) => {
    try {
      await deleteItem(id);
      message.success('Item deleted successfully');
    } catch (error) {
      // Error handled by store
    }
  };

  const columns = [
    {
      title: 'Name',
      dataIndex: 'name',
      key: 'name',
    },
    {
      title: 'Description',
      dataIndex: 'description',
      key: 'description',
    },
    {
      title: 'Created At',
      dataIndex: 'createdAt',
      key: 'createdAt',
      render: (date: string) => new Date(date).toLocaleDateString(),
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_: any, record: any) => (
        <Space>
          <Button
            type="primary"
            size="small"
            icon={<EditOutlined />}
          >
            Edit
          </Button>
          <Button
            type="primary"
            danger
            size="small"
            icon={<DeleteOutlined />}
            onClick={() => handleDelete(record.id)}
          >
            Delete
          </Button>
        </Space>
      ),
    },
  ];` : `
  // Plugin component logic here`}

  return (
    <div style={{ padding: '24px' }}>
      <Card>
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '24px'
        }}>
          <Title level={2}>${pluginName} Dashboard</Title>
          <Button
            type="primary"
            icon={<PlusOutlined />}
          >
            Add New
          </Button>
        </div>

        ${this.options.hasStore ? `<Spin spinning={loading}>
          <Table
            columns={columns}
            dataSource={items}
            rowKey="id"
            pagination={{
              total: items.length,
              pageSize: 10,
              showSizeChanger: true,
              showQuickJumper: true,
            }}
          />
        </Spin>` : `<div>
          <p>${pluginName} plugin dashboard content goes here.</p>
          <p>Implement your plugin functionality in this component.</p>
        </div>`}
      </Card>
    </div>
  );
};

export default ${pluginName}Dashboard;
`;
  }

  getTestTemplate(pluginName) {
    return `/**
 * @fileoverview ${pluginName} Plugin Tests
 *
 * Unit tests for ${pluginName} plugin
 * Generated by AI-First SaaS React Starter CLI
 */

import { ${pluginName}Plugin } from '../${pluginName}Plugin';
import { setupPluginTest } from '../../../core/plugins/__tests__/pluginTestHelper';

describe('${pluginName}Plugin', () => {
  let plugin: ${pluginName}Plugin;
  let mockContext: any;

  beforeEach(async () => {
    const setup = await setupPluginTest(${pluginName}Plugin, {
      autoActivate: false
    });

    plugin = setup.plugin;
    mockContext = setup.context;
  });

  describe('Plugin Lifecycle', () => {
    it('should install successfully', async () => {
      await expect(plugin.install(mockContext)).resolves.not.toThrow();
    });

    it('should activate successfully', async () => {
      await expect(plugin.activate(mockContext)).resolves.not.toThrow();
    });

    it('should deactivate successfully', async () => {
      await expect(plugin.deactivate()).resolves.not.toThrow();
    });
  });

  describe('Plugin Metadata', () => {
    it('should have correct plugin information', () => {
      expect(plugin.name).toBe('${pluginName}');
      expect(plugin.version).toBe('1.0.0');
      expect(plugin.description).toContain('${pluginName}');
      expect(plugin.author).toBe('AI-First SaaS');
    });
  });

  describe('Event Listeners', () => {
    it('should register event listeners', () => {
      const listeners = plugin.getEventListeners();
      expect(listeners).toHaveLength(2);
      expect(listeners[0].eventType).toContain('auth');
      expect(listeners[1].eventType).toContain('tenant');
    });
  });${this.options.hasStore ? `

  describe('Store Registration', () => {
    it('should register plugin store', () => {
      const stores = plugin.registerStores(mockContext);
      expect(stores).toHaveProperty('${pluginName.toLowerCase()}');
      expect(typeof stores.${pluginName.toLowerCase()}).toBe('function');
    });
  });` : ''}${this.options.withRoutes ? `

  describe('Route Registration', () => {
    it('should register plugin routes', () => {
      const routes = plugin.registerRoutes(mockContext);
      expect(Array.isArray(routes)).toBe(true);
      expect(routes.length).toBeGreaterThan(0);
      expect(routes[0]).toHaveProperty('path');
      expect(routes[0]).toHaveProperty('component');
    });
  });` : ''}
});
`;
  }

  getIndexTemplate(pluginName) {
    return `/**
 * @fileoverview ${pluginName} Plugin Exports
 *
 * Main exports for ${pluginName} plugin
 * Generated by AI-First SaaS React Starter CLI
 */

export { ${pluginName}Plugin } from './${pluginName}Plugin';${this.options.hasStore ? `
export { use${pluginName}Store } from './stores/${pluginName}Store';` : ''}${this.options.withRoutes ? `
export { ${pluginName.toLowerCase()}Routes } from './${pluginName}Routes';` : ''}${this.options.withComponents ? `
export { ${pluginName}Dashboard } from './components/${pluginName}Dashboard';` : ''}

// Plugin metadata
export const ${pluginName.toUpperCase()}_PLUGIN_INFO = {
  name: '${pluginName}',
  version: '1.0.0',
  type: '${this.options.type}',
  features: [${this.getFeaturesList()}]
};
`;
  }

  getEventImports() {
    return 'AUTH_EVENTS, TENANT_EVENTS';
  }

  getFeaturesList() {
    const features = [this.options.type];
    if (this.options.hasStore) features.push('store');
    if (this.options.withRoutes) features.push('routing');
    if (this.options.withComponents) features.push('ui');
    return features.map(f => `'${f}'`).join(', ');
  }
}

/**
 * Generate a new plugin
 */
async function generatePlugin(pluginName, options = {}) {
  const generator = new PluginGenerator(options);
  await generator.generate(pluginName);
}

module.exports = {
  PluginGenerator,
  generatePlugin
};